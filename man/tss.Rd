% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmm.R
\name{tss}
\alias{tss}
\title{Find promoter peaks using 3 basepair tie-breaking.}
\usage{
tss(signal, ranges, pairs = FALSE)
}
\arguments{
\item{signal}{Stranded, single base \code{GRanges} with integer score.}

\item{ranges}{\code{GRanges} to limit signal search.}

\item{pairs}{Whether to embed the \code{GRanges} into a \code{Pairs} object
with the stranded range in which the TSS was found.}
}
\value{
Stranded, single base \code{GRanges} with integer score.  If
}
\description{
The original method for extracting the TSS was using 2 basepair windows, but
note that this detail was not documented in
\insertCite{core_analysis_2014}{tsshmm}.  Preserving the intention of that
method to use neighboring counts to break ties, this method uses 3 basepair
overlapping windows, where the preceding and succeeding basepair counts act
as a "bonus" value to help break ties.
}
\examples{
# When counts are equal, TSS returns first maximum.
signal <- GRanges(c("chr1:100:+", "chr1:200:+"), score = c(9L, 9L))
signal
tss <- tss(signal, range(signal))
tss
stopifnot(tss == signal[1])

# Neighboring "bonus" counts break such ties:

# Look 1 basepair ahead to choose the maximum.
signal_ahead <- c(signal, GRanges("chr1:201:+", score = 1L))
signal_ahead
tss_ahead <- tss(signal_ahead, range(signal_ahead))
tss_ahead
stopifnot(tss_ahead == signal_ahead[2])

# Look 1 basepair behind to choose the maximum.
signal_behind <- c(GRanges("chr1:99:+", score = 2L), signal_ahead)
signal_behind
tss_behind <- tss(signal_behind, range(signal_behind))
tss_behind
stopifnot(tss_behind == signal_behind[2])

# Both, look ahead and look behind tie breaking.
signal_both <- sort(c(GRanges("chr1:199:+", score = 2L), signal_behind))
signal_both
tss_both <- tss(signal_both, range(signal_both))
tss_both
stopifnot(tss_both == signal_both[4])

# Return Pairs with found region.
pairs <- tss(signal_both, range(signal_both), pairs = TRUE)
pairs
stopifnot(first(pairs) == tss_both)
stopifnot(second(pairs) == range(signal_both))
}
